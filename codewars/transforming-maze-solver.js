/**
 * 原网站: {@link https://www.codewars.com/kata/transforming-maze-solver/train/javascript}
 * 要求:
 *      1. 所有格子 会定时同步顺时针90度旋转
 *      2. 每个格子可有 [0-4]面墙阻挡
 *      3. 每个格子指定的 数字[1-15] 它的二进制表示它有几面墙
 *          比如: 7 它的二进制为: 0111
 *          从北 -> 西 开始, 所以它的墙的位置是:
 *
 *                          西   东
 *                            南
 *                         为墙
 *          可以从北部进入
 *      4. 有两个特殊的值会分配给格子
 *          - B 代表当前的 球的位置
 *          - X 表示终点
 *      5.  每次B都可以在可通行的位置上进行无限次的移动, 但是只记录起点到终点的轨迹 使用 NESW 来表示
 *      6. 每次cell的wall发生改变, 他的"值"也发生变化
 *  思考:
 *      最终目的是从西走到东, 并移动到指定的位置
 *      1.  从终点开始计算可能性
 *
 *          -   同一列终点可以到达的位置(这个包含有 四个 Interval 的可能性), 只要能到 这些都可以作为起点, 到不了的则放弃计算
 *          -   拿到这些点之后, 检查他们和联通的相邻列的点, 考虑进入时的 Timing, 计算该Timing 下的流通性, 再回到上一步
 *
 *      2.  数据结构
 *          | 好的数据结构是成功的一半
 *          class Cell {
 *              Board: board
 *              Int: x, y,
 *              OriginWall: Int
 *                  -> 计算出四个Timing 下的 walls
 *              N:  Cell
 *              S:  Cell
 *              W:  Cell
 *              E:  Cell
 *
 *
 *          }
 *
 *          class Board {
 *              Timing:
 *         }
 *      3.  计算列上的可能性
 *          -   在 1 中已经论述了, 只要能在任意 Timing 下联通的 上下节点都可以算作起点
 *          -   如何计算列的相通性
 *              -   5 是 [0101], 上下是相通的, 其上是 [xx0x]就可以到达, 其下是 [0xxx]也都可到达
 *          -   计算行的相通性
 *              -   5 是 [0101], 和左右都不相通, 但是Timing的改变 他会变成 [1010], 再计算相通性
 *      4.  计算的方式
 *          答案可能有很多种, 但是题目需要提供最短路径, 所以还是要穷举比较才能得出
 *          Next:   优化方案:
 *          -   先计算上下联通的cell有哪些
 *          -   再计算他们各自往左的 Timing 时长,
 *
 *
 * @param {[Number, Number]} ar - [m,n] m x n 的大小的一个矩形迷宫
 * @return
 */
function mazeSolver(ar) {

}